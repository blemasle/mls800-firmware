#include "MLS800.h"

//read user input and map from the power of two to button number
uint8_t readInput()
{
	_inputInterrupted = false;
	//active input is LOW, inverting the uint8_ts
	uint16_t current = ~_display.read();

	uint8_t value = 1;

	//interrupt was generated by an input release
	if (current == LOW) return current;

	while (current != 1) {
		current = current >> 1;
		value++;
	}

#ifdef REV_A
	/* pcb rev A has some errors that we need to compensate :
	*  bttn DP is last instead of first : change the value so it is transparent for outer code
	*  DP which is the MSB in the keyscan register become the LSB for the program
	*  DP A B C D E F G is understood as A B C D E F G DP
	*/
	if(value > 8 && value < 16) value += 1;
	else if (value == 16) value = 9;
#endif

	return value;
}

void applyLoopStates(uint8_t state)
{

	_loops.write(state | ~reverseByte(state) << 8);
	delay(7);
	//lay down the previous impulse
	_loops.write(0x0000);
	debugPrint("applied state : ");
	debugPrintlnBase(state, BIN);
}

//see http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious
uint8_t reverseByte(uint8_t v)
{
	uint8_t r = v; // r will be reversed bits of v; first get LSB of v
	int s = sizeof(uint8_t) * 8 - 1; // extra shift needed at end

	for (v >>= 1; v; v >>= 1) {
		r <<= 1;
		r |= v & 1;
		s--;
	}
	return r <<= s; // shift when v's highest bits are zero
}